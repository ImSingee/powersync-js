{"version":3,"file":"vendors-node_modules_async-mutex_index_mjs-node_modules_comlink_dist_esm_comlink_mjs-node_mod-037150.index.umd.js","mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC57BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://sdk_web/../../node_modules/async-mutex/index.mjs?2d5f","webpack://sdk_web/../../node_modules/comlink/dist/esm/comlink.mjs","webpack://sdk_web/../../node_modules/@journeyapps/wa-sqlite/src/sqlite-api.js","webpack://sdk_web/../../node_modules/@journeyapps/wa-sqlite/src/sqlite-constants.js"],"sourcesContent":["const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._weightedQueues = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            if (!this._weightedQueues[weight - 1])\n                this._weightedQueues[weight - 1] = [];\n            this._weightedQueues[weight - 1].push({ resolve, reject });\n            this._dispatch();\n        });\n    }\n    runExclusive(callback, weight = 1) {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            const [value, release] = yield this.acquire(weight);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve) => {\n            if (!this._weightedWaiters[weight - 1])\n                this._weightedWaiters[weight - 1] = [];\n            this._weightedWaiters[weight - 1].push(resolve);\n            this._dispatch();\n        });\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatch();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatch();\n    }\n    cancel() {\n        this._weightedQueues.forEach((queue) => queue.forEach((entry) => entry.reject(this._cancelError)));\n        this._weightedQueues = [];\n    }\n    _dispatch() {\n        var _a;\n        for (let weight = this._value; weight > 0; weight--) {\n            const queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();\n            if (!queueEntry)\n                continue;\n            const previousValue = this._value;\n            const previousWeight = weight;\n            this._value -= weight;\n            weight = this._value + 1;\n            queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);\n        }\n        this._drainUnlockWaiters();\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        for (let weight = this._value; weight > 0; weight--) {\n            if (!this._weightedWaiters[weight - 1])\n                continue;\n            this._weightedWaiters[weight - 1].forEach((waiter) => waiter());\n            this._weightedWaiters[weight - 1] = [];\n        }\n    }\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, void 0, void 0, function* () {\n            const [, releaser] = yield this._semaphore.acquire();\n            return releaser;\n        });\n    }\n    runExclusive(callback) {\n        return this._semaphore.runExclusive(() => callback());\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock() {\n        return this._semaphore.waitForUnlock();\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weight) => {\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield sync.acquire(weight);\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weight) => {\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                sync.waitForUnlock(weight).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","// Copyright 2021 Roy T. Hashimoto. All Rights Reserved.\n\nimport * as SQLite from './sqlite-constants.js';\nexport * from './sqlite-constants.js';\n\n/**\n * Need to have a serializer for bigint\n * https://github.com/GoogleChromeLabs/jsbi/issues/30\n */\nif (typeof BigInt.prototype['toJSON'] == 'undefined') {\n  BigInt.prototype['toJSON'] = function() {\n    return this.toString();\n  };\n}\n\nconst MAX_INT64 = 0x7fffffffffffffffn;\nconst MIN_INT64 = -0x8000000000000000n;\n\nexport class SQLiteError extends Error {\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n}\n\nconst async = true;\n\nconst onTableChangeCallbacks = {};\nglobalThis.__onTablesChanged = function(db, opType, tableName, rowId) {\n  setTimeout(() => onTableChangeCallbacks[db]?.(opType, tableName, rowId), 0);\n};\n\n/**\n * Builds a Javascript API from the Emscripten module. This API is still\n * low-level and closely corresponds to the C API exported by the module,\n * but differs in some specifics like throwing exceptions on errors.\n * @param {*} Module SQLite Emscripten module\n * @returns {SQLiteAPI}\n */\nexport function Factory(Module) {\n  /** @type {SQLiteAPI} */ const sqlite3 = {};\n\n  const sqliteFreeAddress = Module._getSqliteFree();\n\n  // Allocate some space for 32-bit returned values.\n  const tmp = Module._malloc(8);\n  const tmpPtr = [tmp, tmp + 4];\n\n  // Convert a JS string to a C string. sqlite3_malloc is used to allocate\n  // memory (use sqlite3_free to deallocate).\n  function createUTF8(s) {\n    if (typeof s !== 'string') return 0;\n    const n = Module.lengthBytesUTF8(s);\n    const zts = Module._sqlite3_malloc(n + 1);\n    Module.stringToUTF8(s, zts, n + 1);\n    return zts;\n  }\n\n  /**\n   * Concatenate 32-bit numbers into a 64-bit (signed) BigInt.\n   * @param {number} lo32\n   * @param {number} hi32\n   * @returns {bigint}\n   */\n  function cvt32x2ToBigInt(lo32, hi32) {\n    return (BigInt(hi32) << 32n) | (BigInt(lo32) & 0xffffffffn);\n  }\n\n  // /**\n  //  * Setup table change update callback\n  //  */\n  // var onTableChangedFunctionPointer = Module.addFunction(onTableUpdate);\n  // var passFnPointer = Module.cwrap('passFnPointer', 'undefined', ['number']);\n  // passFnPointer(onTableChangedFunctionPointer);\n  /**\n   * Concatenate 32-bit numbers and return as number or BigInt, depending\n   * on the value.\n   * @param {number} lo32\n   * @param {number} hi32\n   * @returns {number|bigint}\n   */\n  const cvt32x2AsSafe = (function() {\n    const hiMax = BigInt(Number.MAX_SAFE_INTEGER) >> 32n;\n    const hiMin = BigInt(Number.MIN_SAFE_INTEGER) >> 32n;\n\n    return function(lo32, hi32) {\n      if (hi32 > hiMax || hi32 < hiMin) {\n        // Can't be expressed as a Number so use BigInt.\n        return cvt32x2ToBigInt(lo32, hi32);\n      } else {\n        // Combine the upper and lower 32-bit numbers. The complication is\n        // that lo32 is a signed integer which makes manipulating its bits\n        // a little tricky - the sign bit gets handled separately.\n        return hi32 * 0x100000000 + (lo32 & 0x7fffffff) - (lo32 & 0x80000000);\n      }\n    };\n  })();\n\n  const databases = new Set();\n  function verifyDatabase(db) {\n    if (!databases.has(db)) {\n      throw new SQLiteError('not a database', SQLite.SQLITE_MISUSE);\n    }\n  }\n\n  const mapStmtToDB = new Map();\n  function verifyStatement(stmt) {\n    if (!mapStmtToDB.has(stmt)) {\n      throw new SQLiteError('not a statement', SQLite.SQLITE_MISUSE);\n    }\n  }\n\n  sqlite3.bind_collection = function(stmt, bindings) {\n    verifyStatement(stmt);\n    const isArray = Array.isArray(bindings);\n    const nBindings = sqlite3.bind_parameter_count(stmt);\n    for (let i = 1; i <= nBindings; ++i) {\n      const key = isArray ? i - 1 : sqlite3.bind_parameter_name(stmt, i);\n      const value = bindings[key];\n      if (value !== undefined) {\n        sqlite3.bind(stmt, i, value);\n      }\n    }\n    return SQLite.SQLITE_OK;\n  };\n\n  sqlite3.bind = function(stmt, i, value) {\n    verifyStatement(stmt);\n    switch (typeof value) {\n      case 'number':\n        if (value === (value | 0)) {\n          return sqlite3.bind_int(stmt, i, value);\n        } else {\n          return sqlite3.bind_double(stmt, i, value);\n        }\n      case 'string':\n        return sqlite3.bind_text(stmt, i, value);\n      default:\n        if (value instanceof Uint8Array || Array.isArray(value)) {\n          return sqlite3.bind_blob(stmt, i, value);\n        } else if (value === null) {\n          return sqlite3.bind_null(stmt, i);\n        } else if (typeof value === 'bigint') {\n          return sqlite3.bind_int64(stmt, i, value);\n        } else if (value === undefined) {\n          // Existing binding (or NULL) will be used.\n          return SQLite.SQLITE_NOTICE;\n        } else {\n          console.warn('unknown binding converted to null', value);\n          return sqlite3.bind_null(stmt, i);\n        }\n    }\n  };\n\n  sqlite3.bind_blob = (function() {\n    const fname = 'sqlite3_bind_blob';\n    const f = Module.cwrap(fname, ...decl('nnnnn:n'));\n    return function(stmt, i, value) {\n      verifyStatement(stmt);\n      // @ts-ignore\n      const byteLength = value.byteLength ?? value.length;\n      const ptr = Module._sqlite3_malloc(byteLength);\n      Module.HEAPU8.subarray(ptr).set(value);\n      const result = f(stmt, i, ptr, byteLength, sqliteFreeAddress);\n      // trace(fname, result);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.bind_parameter_count = (function() {\n    const fname = 'sqlite3_bind_parameter_count';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(stmt) {\n      verifyStatement(stmt);\n      const result = f(stmt);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.bind_double = (function() {\n    const fname = 'sqlite3_bind_double';\n    const f = Module.cwrap(fname, ...decl('nnn:n'));\n    return function(stmt, i, value) {\n      verifyStatement(stmt);\n      const result = f(stmt, i, value);\n      // trace(fname, result);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.bind_int = (function() {\n    const fname = 'sqlite3_bind_int';\n    const f = Module.cwrap(fname, ...decl('nnn:n'));\n    return function(stmt, i, value) {\n      verifyStatement(stmt);\n      if (value > 0x7fffffff || value < -0x80000000) return SQLite.SQLITE_RANGE;\n\n      const result = f(stmt, i, value);\n      // trace(fname, result);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.bind_int64 = (function() {\n    const fname = 'sqlite3_bind_int64';\n    const f = Module.cwrap(fname, ...decl('nnnn:n'));\n    return function(stmt, i, value) {\n      verifyStatement(stmt);\n      if (value > MAX_INT64 || value < MIN_INT64) return SQLite.SQLITE_RANGE;\n\n      const lo32 = value & 0xffffffffn;\n      const hi32 = value >> 32n;\n      const result = f(stmt, i, Number(lo32), Number(hi32));\n      // trace(fname, result);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.bind_null = (function() {\n    const fname = 'sqlite3_bind_null';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, i) {\n      verifyStatement(stmt);\n      const result = f(stmt, i);\n      // trace(fname, result);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.bind_parameter_name = (function() {\n    const fname = 'sqlite3_bind_parameter_name';\n    const f = Module.cwrap(fname, ...decl('n:s'));\n    return function(stmt, i) {\n      verifyStatement(stmt);\n      const result = f(stmt, i);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.bind_text = (function() {\n    const fname = 'sqlite3_bind_text';\n    const f = Module.cwrap(fname, ...decl('nnnnn:n'));\n    return function(stmt, i, value) {\n      verifyStatement(stmt);\n      const ptr = createUTF8(value);\n      const result = f(stmt, i, ptr, -1, sqliteFreeAddress);\n      // trace(fname, result);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.changes = (function() {\n    const fname = 'sqlite3_changes';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(db) {\n      verifyDatabase(db);\n      const result = f(db);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.last_insert_id = (function() {\n    const fname = 'sqlite3_last_insert_rowid';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(db) {\n      verifyDatabase(db);\n      const result = f(db);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.close = (function() {\n    const fname = 'sqlite3_close';\n    const f = Module.cwrap(fname, ...decl('n:n'), { async });\n    return async function(db) {\n      verifyDatabase(db);\n      const result = await f(db);\n      databases.delete(db);\n      return check(fname, result, db);\n    };\n  })();\n\n  sqlite3.column = function(stmt, iCol) {\n    verifyStatement(stmt);\n    const type = sqlite3.column_type(stmt, iCol);\n    switch (type) {\n      case SQLite.SQLITE_BLOB:\n        return sqlite3.column_blob(stmt, iCol);\n      case SQLite.SQLITE_FLOAT:\n        return sqlite3.column_double(stmt, iCol);\n      case SQLite.SQLITE_INTEGER:\n        const lo32 = sqlite3.column_int(stmt, iCol);\n        const hi32 = Module.getTempRet0();\n        return cvt32x2AsSafe(lo32, hi32);\n      case SQLite.SQLITE_NULL:\n        return null;\n      case SQLite.SQLITE_TEXT:\n        return sqlite3.column_text(stmt, iCol);\n      default:\n        throw new SQLiteError('unknown type', type);\n    }\n  };\n\n  sqlite3.column_blob = (function() {\n    const fname = 'sqlite3_column_blob';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const nBytes = sqlite3.column_bytes(stmt, iCol);\n      const address = f(stmt, iCol);\n      const result = Module.HEAPU8.subarray(address, address + nBytes);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.column_bytes = (function() {\n    const fname = 'sqlite3_column_bytes';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.column_count = (function() {\n    const fname = 'sqlite3_column_count';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(stmt) {\n      verifyStatement(stmt);\n      const result = f(stmt);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.column_double = (function() {\n    const fname = 'sqlite3_column_double';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.column_int = (function() {\n    // Retrieve int64 but use only the lower 32 bits. The upper 32-bits are\n    // accessible with Module.getTempRet0().\n    const fname = 'sqlite3_column_int64';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.column_int64 = (function() {\n    const fname = 'sqlite3_column_int64';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const lo32 = f(stmt, iCol);\n      const hi32 = Module.getTempRet0();\n      const result = cvt32x2ToBigInt(lo32, hi32);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.column_name = (function() {\n    const fname = 'sqlite3_column_name';\n    const f = Module.cwrap(fname, ...decl('nn:s'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.column_names = function(stmt) {\n    const columns = [];\n    const nColumns = sqlite3.column_count(stmt);\n    for (let i = 0; i < nColumns; ++i) {\n      columns.push(sqlite3.column_name(stmt, i));\n    }\n    return columns;\n  };\n\n  sqlite3.column_text = (function() {\n    const fname = 'sqlite3_column_text';\n    const f = Module.cwrap(fname, ...decl('nn:s'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.column_type = (function() {\n    const fname = 'sqlite3_column_type';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.create_function = function(db, zFunctionName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {\n    verifyDatabase(db);\n    if (xFunc && !xStep && !xFinal) {\n      const result = Module.createFunction(db, zFunctionName, nArg, eTextRep, pApp, xFunc);\n      return check('sqlite3_create_function', result, db);\n    }\n\n    if (!xFunc && xStep && xFinal) {\n      const result = Module.createAggregate(db, zFunctionName, nArg, eTextRep, pApp, xStep, xFinal);\n      return check('sqlite3_create_function', result, db);\n    }\n\n    throw new SQLiteError('invalid function combination', SQLite.SQLITE_MISUSE);\n  };\n\n  sqlite3.create_module = function(db, zName, module, appData) {\n    verifyDatabase(db);\n    const result = Module.createModule(db, zName, module, appData);\n    return check('sqlite3_create_module', result, db);\n  };\n\n  sqlite3.data_count = (function() {\n    const fname = 'sqlite3_data_count';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(stmt) {\n      verifyStatement(stmt);\n      const result = f(stmt);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.declare_vtab = (function() {\n    const fname = 'sqlite3_declare_vtab';\n    const f = Module.cwrap(fname, ...decl('ns:n'));\n    return function(pVTab, zSQL) {\n      const result = f(pVTab, zSQL);\n      return check('sqlite3_declare_vtab', result);\n    }\n  })();\n\n  sqlite3.exec = async function(db, sql, callback) {\n    for await (const stmt of sqlite3.statements(db, sql)) {\n      let columns;\n      while ((await sqlite3.step(stmt)) === SQLite.SQLITE_ROW) {\n        if (callback) {\n          columns = columns ?? sqlite3.column_names(stmt);\n          const row = sqlite3.row(stmt);\n          await callback(row, columns);\n        }\n      }\n    }\n    return SQLite.SQLITE_OK;\n  };\n\n  sqlite3.finalize = (function() {\n    const fname = 'sqlite3_finalize';\n    const f = Module.cwrap(fname, ...decl('n:n'), { async });\n    return async function(stmt) {\n      if (!mapStmtToDB.has(stmt)) {\n        return SQLite.SQLITE_MISUSE;\n      }\n      const result = await f(stmt);\n\n      const db = mapStmtToDB.get(stmt);\n      mapStmtToDB.delete(stmt);\n\n      // Don't throw on error here. Typically the error has already been\n      // thrown and finalize() is part of the cleanup.\n      return result;\n    };\n  })();\n\n  sqlite3.get_autocommit = (function() {\n    const fname = 'sqlite3_get_autocommit';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(db) {\n      const result = f(db);\n      return result;\n    };\n  })();\n\n  sqlite3.libversion = (function() {\n    const fname = 'sqlite3_libversion';\n    const f = Module.cwrap(fname, ...decl(':s'));\n    return function() {\n      const result = f();\n      return result;\n    };\n  })();\n\n  sqlite3.libversion_number = (function() {\n    const fname = 'sqlite3_libversion_number';\n    const f = Module.cwrap(fname, ...decl(':n'));\n    return function() {\n      const result = f();\n      return result;\n    };\n  })();\n\n  sqlite3.limit = (function() {\n    const fname = 'sqlite3_limit';\n    const f = Module.cwrap(fname, ...decl('nnn:n'));\n    return function(db, id, newVal) {\n      const result = f(db, id, newVal);\n      return result;\n    };\n  })();\n\n  sqlite3.open_v2 = (function() {\n    const fname = 'sqlite3_open_v2';\n    const f = Module.cwrap(fname, ...decl('snnn:n'), { async });\n    return async function(zFilename, flags, zVfs) {\n      flags = flags || SQLite.SQLITE_OPEN_CREATE | SQLite.SQLITE_OPEN_READWRITE;\n      zVfs = createUTF8(zVfs);\n      Module.ccall('setup_powersync', 'int', []);\n\n      const result = await f(zFilename, tmpPtr[0], flags, zVfs);\n\n      const db = Module.getValue(tmpPtr[0], '*');\n\n      databases.add(db);\n      Module._sqlite3_free(zVfs);\n\n      Module.ccall('RegisterExtensionFunctions', 'void', ['number'], [db]);\n      check(fname, result);\n      return db;\n    };\n  })();\n\n  sqlite3.register_table_onchange_hook = function(db, callback) {\n    // Register hooks for this DB as a global hook\n    // It will call the global handler above\n    Module.ccall('register_table_update_hook', 'int', ['number'], [db]);\n\n    onTableChangeCallbacks[db] = function(opType, tableNamePtr, rowId) {\n      // Need to get the string from the pointer\n      // const tableName = Module.UTF8ToString(Module.getValue(tableNamePtr, '*'));\n      const memory = new DataView(Module.HEAPU8.buffer);\n\n      // Find the null terminator to determine the string length\n      let length = 0;\n      while (memory.getUint8(tableNamePtr + length) !== 0) {\n        length++;\n      }\n\n      // Extract the string content\n      const stringBytes = new Uint8Array(Module.HEAPU8.buffer, tableNamePtr, length);\n      const tableName = new TextDecoder().decode(stringBytes);\n\n      return callback(opType, tableName, rowId);\n    };\n  };\n\n  sqlite3.prepare_v2 = (function() {\n    const fname = 'sqlite3_prepare_v2';\n    const f = Module.cwrap(fname, ...decl('nnnnn:n'), { async });\n    return async function(db, sql) {\n      const result = await f(db, sql, -1, tmpPtr[0], tmpPtr[1]);\n      check(fname, result, db);\n\n      const stmt = Module.getValue(tmpPtr[0], '*');\n      if (stmt) {\n        mapStmtToDB.set(stmt, db);\n        return { stmt, sql: Module.getValue(tmpPtr[1], '*') };\n      }\n      return null;\n    };\n  })();\n\n  sqlite3.progress_handler = function(db, nProgressOps, handler, userData) {\n    verifyDatabase(db);\n    Module.progressHandler(db, nProgressOps, handler, userData);\n  };\n\n  sqlite3.reset = (function() {\n    const fname = 'sqlite3_reset';\n    const f = Module.cwrap(fname, ...decl('n:n'), { async });\n    return async function(stmt) {\n      verifyStatement(stmt);\n      const result = await f(stmt);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.result = function(context, value) {\n    switch (typeof value) {\n      case 'number':\n        if (value === (value | 0)) {\n          sqlite3.result_int(context, value);\n        } else {\n          sqlite3.result_double(context, value);\n        }\n        break;\n      case 'string':\n        sqlite3.result_text(context, value);\n        break;\n      default:\n        if (value instanceof Uint8Array || Array.isArray(value)) {\n          sqlite3.result_blob(context, value);\n        } else if (value === null) {\n          sqlite3.result_null(context);\n        } else if (typeof value === 'bigint') {\n          return sqlite3.result_int64(context, value);\n        } else {\n          console.warn('unknown result converted to null', value);\n          sqlite3.result_null(context);\n        }\n        break;\n    }\n  };\n\n  sqlite3.result_blob = (function() {\n    const fname = 'sqlite3_result_blob';\n    const f = Module.cwrap(fname, ...decl('nnnn:n'));\n    return function(context, value) {\n      // @ts-ignore\n      const byteLength = value.byteLength ?? value.length;\n      const ptr = Module._sqlite3_malloc(byteLength);\n      Module.HEAPU8.subarray(ptr).set(value);\n      f(context, ptr, byteLength, sqliteFreeAddress); // void return\n    };\n  })();\n\n  sqlite3.result_double = (function() {\n    const fname = 'sqlite3_result_double';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(context, value) {\n      f(context, value); // void return\n    };\n  })();\n\n  sqlite3.result_int = (function() {\n    const fname = 'sqlite3_result_int';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(context, value) {\n      f(context, value); // void return\n    };\n  })();\n\n  sqlite3.result_int64 = (function() {\n    const fname = 'sqlite3_result_int64';\n    const f = Module.cwrap(fname, ...decl('nnn:n'));\n    return function(context, value) {\n      if (value > MAX_INT64 || value < MIN_INT64) return SQLite.SQLITE_RANGE;\n\n      const lo32 = value & 0xffffffffn;\n      const hi32 = value >> 32n;\n      f(context, Number(lo32), Number(hi32)); // void return\n    };\n  })();\n\n  sqlite3.result_null = (function() {\n    const fname = 'sqlite3_result_null';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(context) {\n      f(context); // void return\n    };\n  })();\n\n  sqlite3.result_text = (function() {\n    const fname = 'sqlite3_result_text';\n    const f = Module.cwrap(fname, ...decl('nnnn:n'));\n    return function(context, value) {\n      const ptr = createUTF8(value);\n      f(context, ptr, -1, sqliteFreeAddress); // void return\n    };\n  })();\n\n  sqlite3.row = function(stmt) {\n    const row = [];\n    const nColumns = sqlite3.data_count(stmt);\n    for (let i = 0; i < nColumns; ++i) {\n      const value = sqlite3.column(stmt, i);\n\n      // Copy blob if aliasing volatile WebAssembly memory. This avoids an\n      // unnecessary copy if users monkey patch column_blob to copy.\n      // @ts-ignore\n      row.push(value?.buffer === Module.HEAPU8.buffer ? value.slice() : value);\n    }\n    return row;\n  };\n\n  sqlite3.set_authorizer = function(db, authFunction, userData) {\n    verifyDatabase(db);\n    const result = Module.setAuthorizer(db, authFunction, userData);\n    return check('sqlite3_set_authorizer', result, db);\n  };\n\n  sqlite3.sql = (function() {\n    const fname = 'sqlite3_sql';\n    const f = Module.cwrap(fname, ...decl('n:s'));\n    return function(stmt) {\n      verifyStatement(stmt);\n      const result = f(stmt);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.statements = function(db, sql) {\n    return (async function*() {\n      const str = sqlite3.str_new(db, sql);\n      let prepared = { stmt: null, sql: sqlite3.str_value(str) };\n      try {\n        while ((prepared = await sqlite3.prepare_v2(db, prepared.sql))) {\n          // console.log(sqlite3.sql(prepared.stmt));\n          yield prepared.stmt;\n          sqlite3.finalize(prepared.stmt);\n          prepared.stmt = null;\n        }\n      } finally {\n        if (prepared?.stmt) {\n          sqlite3.finalize(prepared.stmt);\n        }\n        sqlite3.str_finish(str);\n      }\n    })();\n  };\n\n  sqlite3.step = (function() {\n    const fname = 'sqlite3_step';\n    const f = Module.cwrap(fname, ...decl('n:n'), { async });\n    return async function(stmt) {\n      verifyStatement(stmt);\n      const result = await f(stmt);\n      return check(fname, result, mapStmtToDB.get(stmt), [SQLite.SQLITE_ROW, SQLite.SQLITE_DONE]);\n    };\n  })();\n\n  // Duplicate some of the SQLite dynamic string API but without\n  // calling SQLite (except for memory allocation). We need some way\n  // to transfer Javascript strings and might as well use an API\n  // that mimics the SQLite API.\n  let stringId = 0;\n  const strings = new Map();\n\n  sqlite3.str_new = function(db, s = '') {\n    const sBytes = Module.lengthBytesUTF8(s);\n    const str = stringId++ & 0xffffffff;\n    const data = {\n      offset: Module._sqlite3_malloc(sBytes + 1),\n      bytes: sBytes\n    };\n    strings.set(str, data);\n    Module.stringToUTF8(s, data.offset, data.bytes + 1);\n    return str;\n  };\n\n  sqlite3.str_appendall = function(str, s) {\n    if (!strings.has(str)) {\n      throw new SQLiteError('not a string', SQLite.SQLITE_MISUSE);\n    }\n    const data = strings.get(str);\n\n    const sBytes = Module.lengthBytesUTF8(s);\n    const newBytes = data.bytes + sBytes;\n    const newOffset = Module._sqlite3_malloc(newBytes + 1);\n    const newArray = Module.HEAPU8.subarray(newOffset, newOffset + newBytes + 1);\n    newArray.set(Module.HEAPU8.subarray(data.offset, data.offset + data.bytes));\n    Module.stringToUTF8(s, newOffset + data.bytes, sBytes + 1);\n\n    Module._sqlite3_free(data.offset);\n    data.offset = newOffset;\n    data.bytes = newBytes;\n    strings.set(str, data);\n  };\n\n  sqlite3.str_finish = function(str) {\n    if (!strings.has(str)) {\n      throw new SQLiteError('not a string', SQLite.SQLITE_MISUSE);\n    }\n    const data = strings.get(str);\n    strings.delete(str);\n    Module._sqlite3_free(data.offset);\n  };\n\n  sqlite3.str_value = function(str) {\n    if (!strings.has(str)) {\n      throw new SQLiteError('not a string', SQLite.SQLITE_MISUSE);\n    }\n    return strings.get(str).offset;\n  };\n\n  sqlite3.user_data = function(context) {\n    return Module.getFunctionUserData(context);\n  };\n\n  sqlite3.value = function(pValue) {\n    const type = sqlite3.value_type(pValue);\n    switch (type) {\n      case SQLite.SQLITE_BLOB:\n        return sqlite3.value_blob(pValue);\n      case SQLite.SQLITE_FLOAT:\n        return sqlite3.value_double(pValue);\n      case SQLite.SQLITE_INTEGER:\n        const lo32 = sqlite3.value_int(pValue);\n        const hi32 = Module.getTempRet0();\n        return cvt32x2AsSafe(lo32, hi32);\n      case SQLite.SQLITE_NULL:\n        return null;\n      case SQLite.SQLITE_TEXT:\n        return sqlite3.value_text(pValue);\n      default:\n        throw new SQLiteError('unknown type', type);\n    }\n  };\n\n  sqlite3.value_blob = (function() {\n    const fname = 'sqlite3_value_blob';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const nBytes = sqlite3.value_bytes(pValue);\n      const address = f(pValue);\n      const result = Module.HEAPU8.subarray(address, address + nBytes);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.value_bytes = (function() {\n    const fname = 'sqlite3_value_bytes';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const result = f(pValue);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.value_double = (function() {\n    const fname = 'sqlite3_value_double';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const result = f(pValue);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.value_int = (function() {\n    const fname = 'sqlite3_value_int64';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const result = f(pValue);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.value_int64 = (function() {\n    const fname = 'sqlite3_value_int64';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const lo32 = f(pValue);\n      const hi32 = Module.getTempRet0();\n      const result = cvt32x2ToBigInt(lo32, hi32);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.value_text = (function() {\n    const fname = 'sqlite3_value_text';\n    const f = Module.cwrap(fname, ...decl('n:s'));\n    return function(pValue) {\n      const result = f(pValue);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.value_type = (function() {\n    const fname = 'sqlite3_value_type';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const result = f(pValue);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n\n  sqlite3.vfs_register = function(vfs, makeDefault) {\n    const result = Module.registerVFS(vfs, makeDefault);\n    return check('sqlite3_vfs_register', result);\n  };\n\n  function check(fname, result, db = null, allowed = [SQLite.SQLITE_OK]) {\n    // trace(fname, result);\n    if (allowed.includes(result)) return result;\n    const message = db ? Module.ccall('sqlite3_errmsg', 'string', ['number'], [db]) : fname;\n    throw new SQLiteError(message, result);\n  }\n\n  return sqlite3;\n}\n\nfunction trace(...args) {\n  // const date = new Date();\n  // const t = date.getHours().toString().padStart(2, '0') + ':' +\n  //           date.getMinutes().toString().padStart(2, '0') + ':' +\n  //           date.getSeconds().toString().padStart(2, '0') + '.' +\n  //           date.getMilliseconds().toString().padStart(3, '0');\n  // console.debug(t, ...args);\n}\n\n// Helper function to use a more compact signature specification.\nfunction decl(s) {\n  const result = [];\n  const m = s.match(/([ns@]*):([nsv@])/);\n  switch (m[2]) {\n    case 'n':\n      result.push('number');\n      break;\n    case 's':\n      result.push('string');\n      break;\n    case 'v':\n      result.push(null);\n      break;\n  }\n\n  const args = [];\n  for (let c of m[1]) {\n    switch (c) {\n      case 'n':\n        args.push('number');\n        break;\n      case 's':\n        args.push('string');\n        break;\n    }\n  }\n  result.push(args);\n  return result;\n}\n","// Primary result codes.\n// https://www.sqlite.org/rescode.html\nexport const SQLITE_OK = 0;\nexport const SQLITE_ERROR = 1;\nexport const SQLITE_INTERNAL = 2;\nexport const SQLITE_PERM = 3;\nexport const SQLITE_ABORT = 4;\nexport const SQLITE_BUSY = 5;\nexport const SQLITE_LOCKED = 6;\nexport const SQLITE_NOMEM = 7;\nexport const SQLITE_READONLY = 8;\nexport const SQLITE_INTERRUPT = 9;\nexport const SQLITE_IOERR = 10;\nexport const SQLITE_CORRUPT = 11;\nexport const SQLITE_NOTFOUND = 12;\nexport const SQLITE_FULL = 13;\nexport const SQLITE_CANTOPEN = 14;\nexport const SQLITE_PROTOCOL = 15;\nexport const SQLITE_EMPTY = 16;\nexport const SQLITE_SCHEMA = 17;\nexport const SQLITE_TOOBIG = 18;\nexport const SQLITE_CONSTRAINT = 19;\nexport const SQLITE_MISMATCH = 20;\nexport const SQLITE_MISUSE = 21;\nexport const SQLITE_NOLFS = 22;\nexport const SQLITE_AUTH = 23;\nexport const SQLITE_FORMAT = 24;\nexport const SQLITE_RANGE = 25;\nexport const SQLITE_NOTADB = 26;\nexport const SQLITE_NOTICE = 27;\nexport const SQLITE_WARNING = 28;\nexport const SQLITE_ROW = 100;\nexport const SQLITE_DONE = 101;\n\n// Extended error codes.\nexport const SQLITE_IOERR_ACCESS = 3338;\nexport const SQLITE_IOERR_CHECKRESERVEDLOCK = 3594;\nexport const SQLITE_IOERR_CLOSE = 4106;\nexport const SQLITE_IOERR_DATA = 8202;\nexport const SQLITE_IOERR_DELETE = 2570;\nexport const SQLITE_IOERR_DELETE_NOENT = 5898;\nexport const SQLITE_IOERR_DIR_FSYNC = 1290;\nexport const SQLITE_IOERR_FSTAT = 1802;\nexport const SQLITE_IOERR_FSYNC = 1034;\nexport const SQLITE_IOERR_GETTEMPPATH = 6410;\nexport const SQLITE_IOERR_LOCK = 3850;\nexport const SQLITE_IOERR_NOMEM = 3082;\nexport const SQLITE_IOERR_READ = 266;\nexport const SQLITE_IOERR_RDLOCK = 2314;\nexport const SQLITE_IOERR_SEEK = 5642;\nexport const SQLITE_IOERR_SHORT_READ = 522;\nexport const SQLITE_IOERR_TRUNCATE = 1546;\nexport const SQLITE_IOERR_UNLOCK = 2058;\nexport const SQLITE_IOERR_VNODE = 6922;\nexport const SQLITE_IOERR_WRITE = 778;\nexport const SQLITE_IOERR_BEGIN_ATOMIC = 7434;\nexport const SQLITE_IOERR_COMMIT_ATOMIC = 7690;\nexport const SQLITE_IOERR_ROLLBACK_ATOMIC = 7946;\n\n// Other extended result codes.\nexport const SQLITE_CONSTRAINT_CHECK = 275;\nexport const SQLITE_CONSTRAINT_COMMITHOOK = 531;\nexport const SQLITE_CONSTRAINT_FOREIGNKEY = 787;\nexport const SQLITE_CONSTRAINT_FUNCTION = 1043;\nexport const SQLITE_CONSTRAINT_NOTNULL = 1299;\nexport const SQLITE_CONSTRAINT_PINNED = 2835;\nexport const SQLITE_CONSTRAINT_PRIMARYKEY = 1555;\nexport const SQLITE_CONSTRAINT_ROWID = 2579;\nexport const SQLITE_CONSTRAINT_TRIGGER = 1811;\nexport const SQLITE_CONSTRAINT_UNIQUE = 2067;\nexport const SQLITE_CONSTRAINT_VTAB = 2323;\n\n// Open flags.\n// https://www.sqlite.org/c3ref/c_open_autoproxy.html\nexport const SQLITE_OPEN_READONLY = 0x00000001;\nexport const SQLITE_OPEN_READWRITE = 0x00000002;\nexport const SQLITE_OPEN_CREATE = 0x00000004;\nexport const SQLITE_OPEN_DELETEONCLOSE = 0x00000008;\nexport const SQLITE_OPEN_EXCLUSIVE = 0x00000010;\nexport const SQLITE_OPEN_AUTOPROXY = 0x00000020;\nexport const SQLITE_OPEN_URI = 0x00000040;\nexport const SQLITE_OPEN_MEMORY = 0x00000080;\nexport const SQLITE_OPEN_MAIN_DB = 0x00000100;\nexport const SQLITE_OPEN_TEMP_DB = 0x00000200;\nexport const SQLITE_OPEN_TRANSIENT_DB = 0x00000400;\nexport const SQLITE_OPEN_MAIN_JOURNAL = 0x00000800;\nexport const SQLITE_OPEN_TEMP_JOURNAL = 0x00001000;\nexport const SQLITE_OPEN_SUBJOURNAL = 0x00002000;\nexport const SQLITE_OPEN_SUPER_JOURNAL = 0x00004000;\nexport const SQLITE_OPEN_NOMUTEX = 0x00008000;\nexport const SQLITE_OPEN_FULLMUTEX = 0x00010000;\nexport const SQLITE_OPEN_SHAREDCACHE = 0x00020000;\nexport const SQLITE_OPEN_PRIVATECACHE = 0x00040000;\nexport const SQLITE_OPEN_WAL = 0x00080000;\nexport const SQLITE_OPEN_NOFOLLOW = 0x01000000;\n\n// Locking levels.\n// https://www.sqlite.org/c3ref/c_lock_exclusive.html\nexport const SQLITE_LOCK_NONE = 0;\nexport const SQLITE_LOCK_SHARED = 1;\nexport const SQLITE_LOCK_RESERVED = 2;\nexport const SQLITE_LOCK_PENDING = 3;\nexport const SQLITE_LOCK_EXCLUSIVE = 4;\n\n// Device characteristics.\n// https://www.sqlite.org/c3ref/c_iocap_atomic.html\nexport const SQLITE_IOCAP_ATOMIC = 0x00000001;\nexport const SQLITE_IOCAP_ATOMIC512 = 0x00000002;\nexport const SQLITE_IOCAP_ATOMIC1K = 0x00000004;\nexport const SQLITE_IOCAP_ATOMIC2K = 0x00000008;\nexport const SQLITE_IOCAP_ATOMIC4K = 0x00000010;\nexport const SQLITE_IOCAP_ATOMIC8K = 0x00000020;\nexport const SQLITE_IOCAP_ATOMIC16K = 0x00000040;\nexport const SQLITE_IOCAP_ATOMIC32K = 0x00000080;\nexport const SQLITE_IOCAP_ATOMIC64K = 0x00000100;\nexport const SQLITE_IOCAP_SAFE_APPEND = 0x00000200;\nexport const SQLITE_IOCAP_SEQUENTIAL = 0x00000400;\nexport const SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN = 0x00000800;\nexport const SQLITE_IOCAP_POWERSAFE_OVERWRITE = 0x00001000;\nexport const SQLITE_IOCAP_IMMUTABLE = 0x00002000;\nexport const SQLITE_IOCAP_BATCH_ATOMIC = 0x00004000;\n\n// xAccess flags.\n// https://www.sqlite.org/c3ref/c_access_exists.html\nexport const SQLITE_ACCESS_EXISTS = 0;\nexport const SQLITE_ACCESS_READWRITE = 1;\nexport const SQLITE_ACCESS_READ = 2;\n\n// File control opcodes\n// https://www.sqlite.org/c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlbeginatomicwrite\nexport const SQLITE_FCNTL_LOCKSTATE = 1; \nexport const SQLITE_FCNTL_GET_LOCKPROXYFILE = 2; \nexport const SQLITE_FCNTL_SET_LOCKPROXYFILE = 3; \nexport const SQLITE_FCNTL_LAST_ERRNO = 4; \nexport const SQLITE_FCNTL_SIZE_HINT = 5; \nexport const SQLITE_FCNTL_CHUNK_SIZE = 6; \nexport const SQLITE_FCNTL_FILE_POINTER = 7; \nexport const SQLITE_FCNTL_SYNC_OMITTED = 8; \nexport const SQLITE_FCNTL_WIN32_AV_RETRY = 9; \nexport const SQLITE_FCNTL_PERSIST_WAL = 10; \nexport const SQLITE_FCNTL_OVERWRITE = 11; \nexport const SQLITE_FCNTL_VFSNAME = 12; \nexport const SQLITE_FCNTL_POWERSAFE_OVERWRITE = 13; \nexport const SQLITE_FCNTL_PRAGMA = 14; \nexport const SQLITE_FCNTL_BUSYHANDLER = 15; \nexport const SQLITE_FCNTL_TEMPFILENAME = 16; \nexport const SQLITE_FCNTL_MMAP_SIZE = 18; \nexport const SQLITE_FCNTL_TRACE = 19; \nexport const SQLITE_FCNTL_HAS_MOVED = 20; \nexport const SQLITE_FCNTL_SYNC = 21; \nexport const SQLITE_FCNTL_COMMIT_PHASETWO = 22; \nexport const SQLITE_FCNTL_WIN32_SET_HANDLE = 23; \nexport const SQLITE_FCNTL_WAL_BLOCK = 24; \nexport const SQLITE_FCNTL_ZIPVFS = 25; \nexport const SQLITE_FCNTL_RBU = 26; \nexport const SQLITE_FCNTL_VFS_POINTER = 27; \nexport const SQLITE_FCNTL_JOURNAL_POINTER = 28; \nexport const SQLITE_FCNTL_WIN32_GET_HANDLE = 29; \nexport const SQLITE_FCNTL_PDB = 30; \nexport const SQLITE_FCNTL_BEGIN_ATOMIC_WRITE = 31; \nexport const SQLITE_FCNTL_COMMIT_ATOMIC_WRITE = 32; \nexport const SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE = 33; \nexport const SQLITE_FCNTL_LOCK_TIMEOUT = 34; \nexport const SQLITE_FCNTL_DATA_VERSION = 35; \nexport const SQLITE_FCNTL_SIZE_LIMIT = 36; \nexport const SQLITE_FCNTL_CKPT_DONE = 37; \nexport const SQLITE_FCNTL_RESERVE_BYTES = 38; \nexport const SQLITE_FCNTL_CKPT_START = 39;\n\n// Fundamental datatypes.\n// https://www.sqlite.org/c3ref/c_blob.html\nexport const SQLITE_INTEGER = 1;\nexport const SQLITE_FLOAT = 2;\nexport const SQLITE_TEXT = 3;\nexport const SQLITE_BLOB = 4;\nexport const SQLITE_NULL = 5;\n\n// Special destructor behavior.\n// https://www.sqlite.org/c3ref/c_static.html\nexport const SQLITE_STATIC = 0;\nexport const SQLITE_TRANSIENT = -1;\n\n// Text encodings.\n// https://sqlite.org/c3ref/c_any.html\nexport const SQLITE_UTF8 = 1;     /* IMP: R-37514-35566 */\nexport const SQLITE_UTF16LE = 2;  /* IMP: R-03371-37637 */\nexport const SQLITE_UTF16BE = 3;  /* IMP: R-51971-34154 */\nexport const SQLITE_UTF16 = 4;    /* Use native byte order */\n\n// Module constraint ops.\nexport const SQLITE_INDEX_CONSTRAINT_EQ        = 2;\nexport const SQLITE_INDEX_CONSTRAINT_GT        = 4;\nexport const SQLITE_INDEX_CONSTRAINT_LE        = 8;\nexport const SQLITE_INDEX_CONSTRAINT_LT        = 16;\nexport const SQLITE_INDEX_CONSTRAINT_GE        = 32;\nexport const SQLITE_INDEX_CONSTRAINT_MATCH     = 64;\nexport const SQLITE_INDEX_CONSTRAINT_LIKE      = 65;\nexport const SQLITE_INDEX_CONSTRAINT_GLOB      = 66;\nexport const SQLITE_INDEX_CONSTRAINT_REGEXP    = 67;\nexport const SQLITE_INDEX_CONSTRAINT_NE        = 68;\nexport const SQLITE_INDEX_CONSTRAINT_ISNOT     = 69;\nexport const SQLITE_INDEX_CONSTRAINT_ISNOTNULL = 70;\nexport const SQLITE_INDEX_CONSTRAINT_ISNULL    = 71;\nexport const SQLITE_INDEX_CONSTRAINT_IS        = 72;\nexport const SQLITE_INDEX_CONSTRAINT_FUNCTION  = 150;\nexport const SQLITE_INDEX_SCAN_UNIQUE          = 1;  /* Scan visits at most = 1 row */\n\n// Function flags\nexport const SQLITE_DETERMINISTIC = 0x000000800;\nexport const SQLITE_DIRECTONLY    = 0x000080000;\nexport const SQLITE_SUBTYPE       = 0x000100000;\nexport const SQLITE_INNOCUOUS     = 0x000200000;\n\n// Sync flags\nexport const SQLITE_SYNC_NORMAL   = 0x00002;\nexport const SQLITE_SYNC_FULL     = 0x00003;\nexport const SQLITE_SYNC_DATAONLY = 0x00010;\n\n// Authorizer action codes\nexport const SQLITE_CREATE_INDEX        = 1;\nexport const SQLITE_CREATE_TABLE        = 2;\nexport const SQLITE_CREATE_TEMP_INDEX   = 3;\nexport const SQLITE_CREATE_TEMP_TABLE   = 4;\nexport const SQLITE_CREATE_TEMP_TRIGGER = 5;\nexport const SQLITE_CREATE_TEMP_VIEW    = 6;\nexport const SQLITE_CREATE_TRIGGER      = 7;\nexport const SQLITE_CREATE_VIEW         = 8;\nexport const SQLITE_DELETE              = 9;\nexport const SQLITE_DROP_INDEX          = 10;\nexport const SQLITE_DROP_TABLE          = 11;\nexport const SQLITE_DROP_TEMP_INDEX     = 12;\nexport const SQLITE_DROP_TEMP_TABLE     = 13;\nexport const SQLITE_DROP_TEMP_TRIGGER   = 14;\nexport const SQLITE_DROP_TEMP_VIEW      = 15;\nexport const SQLITE_DROP_TRIGGER        = 16;\nexport const SQLITE_DROP_VIEW           = 17;\nexport const SQLITE_INSERT              = 18;\nexport const SQLITE_PRAGMA              = 19;\nexport const SQLITE_READ                = 20;\nexport const SQLITE_SELECT              = 21;\nexport const SQLITE_TRANSACTION         = 22;\nexport const SQLITE_UPDATE              = 23;\nexport const SQLITE_ATTACH              = 24;\nexport const SQLITE_DETACH              = 25;\nexport const SQLITE_ALTER_TABLE         = 26;\nexport const SQLITE_REINDEX             = 27;\nexport const SQLITE_ANALYZE             = 28;\nexport const SQLITE_CREATE_VTABLE       = 29;\nexport const SQLITE_DROP_VTABLE         = 30;\nexport const SQLITE_FUNCTION            = 31;\nexport const SQLITE_SAVEPOINT           = 32;\nexport const SQLITE_COPY                = 0;\nexport const SQLITE_RECURSIVE           = 33;\n\n// Authorizer return codes\nexport const SQLITE_DENY   = 1;\nexport const SQLITE_IGNORE = 2;\n\n// Limit categories\nexport const SQLITE_LIMIT_LENGTH              = 0;\nexport const SQLITE_LIMIT_SQL_LENGTH          = 1;\nexport const SQLITE_LIMIT_COLUMN              = 2;\nexport const SQLITE_LIMIT_EXPR_DEPTH          = 3;\nexport const SQLITE_LIMIT_COMPOUND_SELECT     = 4;\nexport const SQLITE_LIMIT_VDBE_OP             = 5;\nexport const SQLITE_LIMIT_FUNCTION_ARG        = 6;\nexport const SQLITE_LIMIT_ATTACHED            = 7;\nexport const SQLITE_LIMIT_LIKE_PATTERN_LENGTH = 8;\nexport const SQLITE_LIMIT_VARIABLE_NUMBER     = 9;\nexport const SQLITE_LIMIT_TRIGGER_DEPTH       = 10;\nexport const SQLITE_LIMIT_WORKER_THREADS      = 11;"],"names":[],"sourceRoot":""}