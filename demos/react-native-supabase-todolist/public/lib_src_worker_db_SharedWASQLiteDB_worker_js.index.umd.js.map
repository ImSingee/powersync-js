{"version":3,"file":"lib_src_worker_db_SharedWASQLiteDB_worker_js.index.umd.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AAEA;AAEA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnNA;AACA;AACA;AAYA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACRA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpCA;AACA;AACA;AACA;;;;;AEHA;AACA","sources":["webpack://sdk_web/webpack/universalModuleDefinition","webpack://sdk_web/./src/shared/open-db.ts","webpack://sdk_web/./src/worker/db/SharedWASQLiteDB.worker.ts","webpack://sdk_web/webpack/bootstrap","webpack://sdk_web/webpack/runtime/chunk loaded","webpack://sdk_web/webpack/runtime/define property getters","webpack://sdk_web/webpack/runtime/ensure chunk","webpack://sdk_web/webpack/runtime/get javascript chunk filename","webpack://sdk_web/webpack/runtime/global","webpack://sdk_web/webpack/runtime/hasOwnProperty shorthand","webpack://sdk_web/webpack/runtime/make namespace object","webpack://sdk_web/webpack/runtime/publicPath","webpack://sdk_web/webpack/runtime/importScripts chunk loading","webpack://sdk_web/webpack/runtime/startup chunk dependencies","webpack://sdk_web/webpack/before-startup","webpack://sdk_web/webpack/startup","webpack://sdk_web/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sdk_web\"] = factory();\n\telse\n\t\troot[\"sdk_web\"] = factory();\n})(self, () => {\nreturn ","import * as SQLite from '@journeyapps/wa-sqlite';\nimport '@journeyapps/wa-sqlite';\nimport * as Comlink from 'comlink';\nimport type { DBFunctionsInterface, OnTableChangeCallback, WASQLExecuteResult } from './types';\nimport { Mutex } from 'async-mutex';\n\nlet nextId = 1;\n\nexport async function _openDB(\n  dbFileName: string,\n  options: { useWebWorker: boolean } = { useWebWorker: true }\n): Promise<DBFunctionsInterface> {\n  const { default: moduleFactory } = await import('@journeyapps/wa-sqlite/dist/wa-sqlite-async.mjs');\n  const module = await moduleFactory();\n  const sqlite3 = SQLite.Factory(module);\n\n  const { IDBBatchAtomicVFS } = await import('@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js');\n  const vfs = new IDBBatchAtomicVFS(dbFileName);\n  sqlite3.vfs_register(vfs, true);\n\n  const db = await sqlite3.open_v2(dbFileName);\n  const statementMutex = new Mutex();\n\n  /**\n   * Listeners are exclusive to the DB connection.\n   */\n  const listeners = new Map<number, OnTableChangeCallback>();\n\n  sqlite3.register_table_onchange_hook(db, (opType: number, tableName: string, rowId: number) => {\n    Array.from(listeners.values()).forEach((l) => l(opType, tableName, rowId));\n  });\n\n  /**\n   * This executes single SQL statements inside a requested lock.\n   */\n  const execute = async (sql: string | TemplateStringsArray, bindings?: any[]): Promise<WASQLExecuteResult> => {\n    // Running multiple statements on the same connection concurrently should not be allowed\n    return _acquireExecuteLock(async () => {\n      return executeSingleStatement(sql, bindings);\n    });\n  };\n\n  /**\n   * This requests a lock for executing statements.\n   * Should only be used internally.\n   */\n  const _acquireExecuteLock = <T>(callback: () => Promise<T>): Promise<T> => {\n    return statementMutex.runExclusive(callback);\n  };\n\n  /**\n   * This executes a single statement using SQLite3.\n   */\n  const executeSingleStatement = async (\n    sql: string | TemplateStringsArray,\n    bindings?: any[]\n  ): Promise<WASQLExecuteResult> => {\n    const results = [];\n    for await (const stmt of sqlite3.statements(db, sql as string)) {\n      let columns;\n      const wrappedBindings = bindings ? [bindings] : [[]];\n      for (const binding of wrappedBindings) {\n        // TODO not sure why this is needed currently, but booleans break\n        binding.forEach((b, index, arr) => {\n          if (typeof b == 'boolean') {\n            arr[index] = b ? 1 : 0;\n          }\n        });\n\n        sqlite3.reset(stmt);\n        if (bindings) {\n          sqlite3.bind_collection(stmt, binding);\n        }\n\n        const rows = [];\n        while ((await sqlite3.step(stmt)) === SQLite.SQLITE_ROW) {\n          const row = sqlite3.row(stmt);\n          rows.push(row);\n        }\n\n        columns = columns ?? sqlite3.column_names(stmt);\n        if (columns.length) {\n          results.push({ columns, rows });\n        }\n      }\n\n      // When binding parameters, only a single statement is executed.\n      if (bindings) {\n        break;\n      }\n    }\n\n    const rows: Record<string, any>[] = [];\n    for (const resultset of results) {\n      for (const row of resultset.rows) {\n        const outRow: Record<string, any> = {};\n        resultset.columns.forEach((key, index) => {\n          outRow[key] = row[index];\n        });\n        rows.push(outRow);\n      }\n    }\n\n    const result = {\n      insertId: sqlite3.last_insert_id(db),\n      rowsAffected: sqlite3.changes(db),\n      rows: {\n        _array: rows,\n        length: rows.length\n      }\n    };\n\n    return result;\n  };\n\n  /**\n   * This executes SQL statements in a batch.\n   */\n  const executeBatch = async (sql: string, bindings?: any[][]): Promise<WASQLExecuteResult> => {\n    return _acquireExecuteLock(async (): Promise<WASQLExecuteResult> => {\n      let affectedRows = 0;\n\n      const str = sqlite3.str_new(db, sql);\n      const query = sqlite3.str_value(str);\n      try {\n        await executeSingleStatement('BEGIN TRANSACTION');\n\n        //Prepare statement once\n        const prepared = await sqlite3.prepare_v2(db, query);\n        if (prepared === null) {\n          return {\n            rowsAffected: 0,\n            rows: { _array: [], length: 0 }\n          };\n        }\n        const wrappedBindings = bindings ? bindings : [];\n        for (const binding of wrappedBindings) {\n          // TODO not sure why this is needed currently, but booleans break\n          for (let i = 0; i < binding.length; i++) {\n            const b = binding[i];\n            if (typeof b == 'boolean') {\n              binding[i] = b ? 1 : 0;\n            }\n          }\n\n          //Reset bindings\n          sqlite3.reset(prepared.stmt);\n          if (bindings) {\n            sqlite3.bind_collection(prepared.stmt, binding);\n          }\n\n          const result = await sqlite3.step(prepared.stmt);\n          if (result === SQLite.SQLITE_DONE) {\n            //The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero.\n            affectedRows += sqlite3.changes(db);\n          }\n        }\n        //Finalize prepared statement\n        await sqlite3.finalize(prepared.stmt);\n        await executeSingleStatement('COMMIT');\n      } catch (err) {\n        await executeSingleStatement('ROLLBACK');\n        return {\n          rowsAffected: 0,\n          rows: { _array: [], length: 0 }\n        };\n      } finally {\n        sqlite3.str_finish(str);\n      }\n      const result = {\n        rowsAffected: affectedRows,\n        rows: { _array: [], length: 0 }\n      };\n\n      return result;\n    });\n  };\n\n  if (options.useWebWorker) {\n    const registerOnTableChange = (callback: OnTableChangeCallback) => {\n      const id = nextId++;\n      listeners.set(id, callback);\n      return Comlink.proxy(() => {\n        listeners.delete(id);\n      });\n    };\n\n    return {\n      execute: Comlink.proxy(execute),\n      executeBatch: Comlink.proxy(executeBatch),\n      registerOnTableChange: Comlink.proxy(registerOnTableChange),\n      close: Comlink.proxy(() => {\n        sqlite3.close(db);\n      })\n    };\n  }\n\n  const registerOnTableChange = (callback: OnTableChangeCallback) => {\n    const id = nextId++;\n    listeners.set(id, callback);\n    return () => {\n      listeners.delete(id);\n    };\n  };\n\n  return {\n    execute: execute,\n    executeBatch: executeBatch,\n    registerOnTableChange: registerOnTableChange,\n    close: () => sqlite3.close(db)\n  };\n}\n","import '@journeyapps/wa-sqlite';\nimport * as Comlink from 'comlink';\nimport { _openDB } from '../../shared/open-db';\nimport type { DBFunctionsInterface } from '../../shared/types';\n\n/**\n * Keeps track of open DB connections and the clients which\n * are using it.\n */\ntype SharedDBWorkerConnection = {\n  clientIds: Set<number>;\n  db: DBFunctionsInterface;\n};\n\nconst _self: SharedWorkerGlobalScope = self as any;\n\nconst DBMap = new Map<string, SharedDBWorkerConnection>();\nconst OPEN_DB_LOCK = 'open-wasqlite-db';\n\nlet nextClientId = 1;\n\nconst openDB = async (dbFileName: string): Promise<DBFunctionsInterface> => {\n  // Prevent multiple simultaneous opens from causing race conditions\n  return navigator.locks.request(OPEN_DB_LOCK, async () => {\n    const clientId = nextClientId++;\n\n    if (!DBMap.has(dbFileName)) {\n      const clientIds = new Set<number>();\n      const connection = await _openDB(dbFileName);\n      DBMap.set(dbFileName, {\n        clientIds,\n        db: connection\n      });\n    }\n\n    const dbEntry = DBMap.get(dbFileName)!;\n    dbEntry.clientIds.add(clientId);\n    const { db } = dbEntry;\n\n    const wrappedConnection = {\n      ...db,\n      close: Comlink.proxy(() => {\n        const { clientIds } = dbEntry;\n        clientIds.delete(clientId);\n        if (clientIds.size == 0) {\n          console.debug(`Closing connection to ${dbFileName}.`);\n          DBMap.delete(dbFileName);\n          return db.close?.();\n        }\n        console.debug(`Connection to ${dbFileName} not closed yet due to active clients.`);\n      })\n    };\n\n    return Comlink.proxy(wrappedConnection);\n  });\n};\n\n_self.onconnect = function (event: MessageEvent<string>) {\n  const port = event.ports[0];\n  console.debug('Exposing db on port', port);\n  Comlink.expose(openDB, port);\n};\n\naddEventListener('unload', () => {\n  Array.from(DBMap.values()).forEach(async (dbConnection) => {\n    const db = await dbConnection.db;\n    db.close?.();\n  });\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors-node_modules_async-mutex_index_mjs-node_modules_comlink_dist_esm_comlink_mjs-node_mod-037150\"], () => (__webpack_require__(\"./lib/src/worker/db/SharedWASQLiteDB.worker.js\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".index.umd.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"lib_src_worker_db_SharedWASQLiteDB_worker_js\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunksdk_web\"] = self[\"webpackChunksdk_web\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(\"vendors-node_modules_async-mutex_index_mjs-node_modules_comlink_dist_esm_comlink_mjs-node_mod-037150\").then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":[],"sourceRoot":""}